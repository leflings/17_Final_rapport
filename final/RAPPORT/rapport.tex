\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[danish]{babel}
\usepackage[T1]{fontenc}
\renewcommand{\danishhyphenmins}{22}
\renewcommand{\arraystretch}{1.3}
\usepackage{amsmath,amssymb,bm,mathtools}
\title{Rapport: Gruppe 17 - CDIO Final}
\author{
  Alle
}

\begin{document}
\maketitle

\tableofcontents
\clearpage

\section{Kravspecifikation} % (fold)

\subsection{Analyse} % (fold)
Fra kundens side er der følgende krav til hvad hjemmesiden skal kunne:

\begin{itemize}
  \item Oprette, se, ændre samt slette brugere
  \item Oprette, se og ændre på råvarer
  \item Oprette og se råvarebatch 
  \item Oprette og se recepter
  \item Oprette og se produktionsbatch
  \item Adgangskontrol samt forskellige niveauer
\end{itemize}

Det er også vigtigt at der er stor fokus på brugervenligheden, samt at sikre sig mod at brugerne indtaster forkert data. På hjemmesiden skal brugerne være inddelt i 4 niveauer:

\begin{itemize}
  \item Administrator: Alle rettigheder
  \item Farmaceut: Har ikke adgang til brugeradministration
  \item Værkfører: Har ikke adgang til råvare, recept og bruger administrationen 
  \item Operatør: Har kun adgang til afvejningssystemet. 
\end{itemize}

For alle brugere er der forskellige rettigheder, i forhold til hvilket niveau man hører til. F.eks. har administratoren flere rettigheder end alle andre brugere i systemet. Disse er også delt i use-cases som beskrevet for neden, hvor der specifikt beskrives hvad brugeren kan. 

% subsection Analyse (end)

\subsection{Use Cases} % (fold)

Der er 6 use-cases i systemet

\subsubsection{UC1: Bruger adminstration} % (fold)

Det er kun brugere med niveauet administrator som kan administrer brugere. En bruger består af følgende informationer.

\begin{itemize}
  \item Bruger ID
  \item Navn
  \item Initialer
  \item Kodeord
  \item Niveau
\end{itemize}

En bruger med niveauet Operatør skal ikke kunne slettes eller hæves i niveau når de først er oprettet.  Alle andre brugere skal kunne slettes og opdateres. Det er vigtigt at administratorer ikke kan slette eller sænke sig selv i niveau.   

% subsubsection UC1: Bruger adminstration (end)

\subsubsection{UC2: Råvare adminstration} % (fold)

Farmaceut aktøren står for administrationen af råvarerne i systemet, denne skal kunne oprette, rette og vise råvarer i systemet.

En råvare defineres således:

\begin{itemize}
  \item råvareNr (brugervalgt og entydigt)
  \item råvareNavn
  \item leverandør
\end{itemize}

% subsubsection UC2: Råvare adminstration (end)

\subsubsection{UC3: Recept adminstration} % (fold)

Farmaceut aktøren står for recept administrationen, denne skal kunne oprette og vise recepter i systemet.

En recept defineres således:
\begin{itemize}
  \item receptNr (brugervalgt og entydigt)
  \item receptNavn
  \item sekvens af receptkomponenter
\end{itemize}

En receptkomponent består af råvareType, mængde, og en tolerance.

% subsubsection UC3: Recept adminstration (end)

\subsubsection{UC4: Råvarebatch adminstration} % (fold)

Værkfører aktøren står for administrationen af råvarebatches i systemet. Denne skal kunne oprette og vise råvarebatches i systemet. 

En råvarebatch defineres således:

\begin{itemize}
  \item råvarebatchNr (brugervalgt og entydigt)
  \item mængde
\end{itemize}

% subsubsection UC4: Råvarebatch adminstration (end)

\subsubsection{UC5: Produktbatch adminstration} % (fold)

Værkfører aktøren står for administrationen af produktbatches i systemet. Denne skal kunne oprette og vise produktbatches i systemet.

En produktbatch defineres således:

\begin{itemize}
  \item produktbatchNr (entydigt)
  \item nummeret på recepten produktbatchen produceres udfra
  \item oprettelses dato
  \item oplysinger om batchens status, status kan være: oprettet/ under produktion/ afsluttet.
\end{itemize}

Resultaterne af de enkelte receptkomponenter gemmes som en produktbatchkomponent i produktbatchen samtidig med at produktet fremstilles.

Efter værkføren har oprettet en ny produktbatch, udprintes den og uddeles til en udvalgt operatør. Operatøren har derefter ansvaret for produktionen. 

For ovennævnte UC1-UC5 ønskes at der fokuseres på brugervenlighed samt input validering.

% subsubsection UC5: Produktbatch adminstration (end)

\subsubsection{UC6: Afvejning} % (fold)

Operatøren arbejder ved en vejeterminal og starter med at identificere sig overfor den. Det gøres ved at indtaste operatørNr på vejeterminalens tastatur. Vejeterminalen svarer derefter tilbage med operatørens navn som vises på displayet, herefter indtaster operatøren nummeret på den produktbatch der skal produceres.

Vejeterminalen beder derefter operatøren om at placere en tarabeholder på vejeplatformen, hvor beholderens vægt registreres i produktbatchkomponenten. Herefter sender vejeterminalen oplysninger om hvilket råvare nummer der skal afvejes. Når operatøren har hentet en passende mængde af den ønskede råvare, skal han oplyse hvilket batch nummer denne aktuelle råvarebatch har.

Herefter foretages der en afvejning på vejeterminalen, afvejningsresultatet accepteres først når det ligger indenfor den tolerance der er angivet i recepten. Når afvejningsresultatet er blevet accepteret, registreres det i produktbatchkomponenten. 

Proceduren bliver gentaget for samtlige råvarer i recepten. Undervejs i forløbet, ændres status i produktbatchen fra ”oprettet” til ”under produktion”, når første komponent er afvejet, til sidst ændres den til ”afsluttet” når alle komponenter i recepten er afvejet.

Det vigtige for virksomheden er, at det nye softwaresystem ikke ændrer operatørernes vante arbejdsrutiner, som de kender fra det nuværende system.

Der lægges vægt på at afvejningsproceduren er brugervenlig, intuitiv, fejltolerant samt sikre at det aktuelle afvejede afspejler det ønskede og at de konkrete afvejningsresultater registreres.

% subsubsection UC6: Afvejning (end)

% subsection Use Cases (end)

\subsection{Systemarkitektur} % (fold)

Systemet skal bestå af disse delkomponenter:

\begin{itemize}
  \item En database der indeholder oplysninger om operatører, råvarer, råvarebatches, recepter, samt de planlagte og færdigproducerede produktbatches. 
    \begin{itemize}
      \item Datalaget der er i applikationen skal implementeres som en MysSql database.
    \end{itemize}
  \item Et webinterface (GUI), hvor farmaceuten kan administrere recepterne og råvarerne, og hvor værkføreren kan oprette produktbatches og vise deres status.
  \item En række vejeterminaler som er udstyret med vejeplade, tastatur og display. Alle vægte har et ethernet interface. 
  \item Et program (ASE) til styrelse af alle vejeterminaler og gemmer dens data i databasen.
\end{itemize}

% subsection Systemarkitektur (end)

\subsection{ASE specifikation} % (fold)

Afvejnings styrings endheden (ASE) er en applikation, denne står for at styre afvejningsproceduren på vægten. Applikationen styrer vægten/vægtsimulatoren. 

Programmet skal starte med at bede om operatør nr. operatøren indtaster derefter sit operatør nr. og denne afvejnings procedure følger herefter.

 (Afvejningsprocedure)

Den afvejningsprocedure som der tages udgangspunkt i, er den fra opgaveformuleringen som var beskrevet i bilag 4. De nærmere specifikationer for den modificerede afvejnigsprocedure som vi har brugt, er beskrevet i et andet afsnit. 

% subsection ASE specifikation (end)

\subsection{Website specifikation} % (fold)

Web applikationen skal implementere use-casene 1-5.

Når brugerne er i gang med en login session skal der foretages en authentikering. I forhold til den rolle brugeren har, skal siderne vises tilpasset brugerens rettigheder, herunder relevante menuer.

Input felterne skal valideres i henhold til gyldige områder, og der skal vises passende fejlmeddelelser ved fejl. Websiderne bør valideres i henhold til W3C standarderne, og det gælder her både HTML og Cascading Style Sheets (CSS).

% subsection Website specifikation (end)

\subsection{Simulator specifikation} % (fold)

Vi har valgt at implementere en GUI baseret simulator, hvor vi også har valgt disse kommandoer som en del af implementeringen.

Kommandoer:

\begin{itemize}
  \item S, T, Z
  \item RM20 8, RM30, RM39, RM49 2, RM49 4
  \item P111, P110
\end{itemize}

% subsection Simulator specifikation (end)

% section Kravspecifikation (end)

\section{Database} % (fold)

\subsection{Analyse} % (fold)

Databasens opgave er at opbevare de data som brugerne af systemet gemmer, således at det gemte data kan tilgås på et andet tidspunkt. En database er opbygget af en eller flere entiteter indeholdende en eller flere felter. Databasen entiteter kan være knyttet til hinanden ved hjælp af primære nøgler og fremmednøgler. Det er muligt at tilgå en database på mange forskellige måde og derfor skal man også være påpasselig når man integrer en database i sit system, da man ikke altid vil have alle dele af systemet skal have mulighed for at tilgå databasen. Der findes flere design mønstre der tager hånd om dette problem men en af de mere udbredte er Data Access Object eller DAO og Data Transfer Object eller DTO. Når en del af et system så skal have data ud af en database kontakter delsystemet DAO’et som tilgår databasen og gemmer de udtagende data i et DTO, som delsystemet så kan tilgå. På den måde sikre man at resten af systemet ikke kan tilgå databasen. Man kan sige at DAO er et abstrakt interface til en entitet i databasen.

I kundens oplæg systemet fremgår det at databasen skal inde holde følgende entiteter: ”Raavare, RaavareBatch, Recept, ProduktBatch, og Operatoer. Disse entiteter indeholder forskellige felter. Hvert felt har et område af lovlige værdier som det data der skal lagres skal være indenfor.
Systemet skal være bygget op således at man adskiller databasen fra de andre dele af systemet ved hjælp af et data acces lag.


% subsection Analyse (end)

\subsection{Design} % (fold)

Vi har valgt at vores design af DAO’er og DTO’er til dels følger det forslag som oplæget foreslog. Det vil sige at vi for hver entitet i databasen har et DAO interface og et DTO. Hvert DAO interface har desuden en klasse der implementer interfacet.  Vi har udover forslaget valgt at oprette en entitet ReceptKomp. 

% subsection Design (end)

\subsection{Implementation} % (fold)

% subsection Implementation (end)

\subsection{Test} % (fold)

Da vores DTO’er kun består af get’er og set’er og en for DTO’ets egne felter og en equal-metode har vi ment at JUnit tests ikke var nødvendig. Vi har lavet black box testing af vores database og DAO’er ved hjælp af systemets webservice del. Her har vi prøvet at oprette, slette og ændre de forskellige eniteter og felter i databasen. Nedenfor ses et skemaer over de forskellige black box test vi har lavet.

% subsection Test (end)

% section Database (end)

\section{Hjemmeside} % (fold)

\subsection{Analyse} % (fold)

Hjemmesiden skal fungere som administrations konsol til afvejningen og dens tilhørerne processor.  Det skal være muligt at styre produktionen af medicin fra oprettelsen af brugere til opfølgningen og styring af recepterne.  Hjemmesiden skal være delt op i forskellige lag, således at det er muligt at styre hvilke brugere der har adgange til hvilke del elementer i produktionen. I systemet er der 4 forskellige brugerniveauer
\begin{itemize}
  \item Operatøren: Har adgang til afvejningen af råvare samt til at se hvilke råvare der skal i produktionsbatches.
  \item Værksføreren: Har administrationen af råvarebatches og produktbatches samt operatørens rettigheder.
  \item Farmaceuten: Adgang til administrationen af råvare og recepter samt værksførerens adgange. 
  \item Administratoren: Har adgang til alle dele af systemet, kan yderligere oprette, slettet og redigerer brugere.
\end{itemize}
I kundens oplæg til produktet er det en del af værksførerens opgaver, at ud printe og uddelegerer en produktion batch til en operatør. Vi har grunden udbredelsen af smartphones valgt i stedet at lave et website, optimeret til at virke på små skærme, hvor på operatøren kan logge ind og se hvilke råvare der mangler at blive afvejet til en hvilken som helst produktionsbatch. 

% subsection Analyse (end)

\subsection{Design} % (fold)

Hjemmesiden bliver kodet efter Model–View–Controller principperne. Siden vil blive styret af en Java servlet som står funger som Controller. Viewet vil blive genereret af JSP sider, og Java Beans er modellen.  Hjemmesiden er event baseret, og controlleren vil ud fra disse events genererer de nødvendige modeller og dirigere brugeren ud på de korrekt views.

\begin{center}
  \textbf{Indsæt billede af MVC-model}
\end{center}

De forskellige views vil ikke komme til at kende hinanden, da det er controlleren som har det overordnede kendskab til alle jsp siderne. Dette betyder også at adgangskontroller kun ligger et centralt sted, og derved er det nemt at styre.

\subsubsection{Grafisk design} % (fold)

Til at designe den grafiske del af hjemmesiden har vi valgt at benytte 3. parts biblioteket Twitter Bootstrap .  Twitter Bootstrap er et simpelt og fleksibelt CSS og JavaScipt bibliotek som gør det nemt at sætte hjemmeside ens op på tværs af browsere. Siden vil blive bygget op af i 3 dele. Menuen som vil blive placeret yderst til venstre og altid vil være synlig. Til højre for menuen der blive vist hvad end brugeren har valgt, det kunne for eksempel være brugeradministrationen vinduet. Under dette vil der være beskeder til brugeren, det kunne være beskeder om den valgte operation er gået godt eller har fejlet.

\begin{center}
  \textbf{Indsæt billede af design-mockup}
\end{center}

% subsubsection Grafisk design (end)

\subsubsection{Input validering} % (fold)

For at gøre oplevelsen af hjemmesiden så brugervenlig som muligt benytter vi os af inputvalidering både på serversiden, men også på klientsiden. Valideringen på klient siden gør at vi kan gøre brugeren opmærksom på problemer lige så snart informationen er indtastet i inputfelterne. Hvis der opstår et problem, vil brugeren blive gjort opmærksom på dette ved at inputfelterne lyser rødt, og at der kommer en lille besked om hvad feltet kræver.  Før at klientside valideringen er tilfreds, er det ikke muligt at trykke på ”Ok” eller ”Godkend” knapperne.  
Til at lave klient valideringen benytter vi 3. parts JavaScript biblioteket  jQuery  og dens plugin ”validator”. Grunden til at vi benytter jQuery er at det er funger på alle browsere, hvilket gør det nemt at få funktioner til at virke uanset hvilken browser brugeren bruger. 
Lige vise hvordan det er sat op
For at sikre at udefremkommende ikke kan lave ulovlige ændringer, har vi også en serverside validering som består af en masse regular expressions. Denne validering fremtvinger ikke en pæn fejlmeddelelse, men gør kun brugeren opmærksom på at der er sket en fejl i valideringen. Det er derfor ikke muligt at gennemtvinge oprettelser eller ændringer ved bare at ændre på vores klientside validering. 

% subsubsection Input validering (end)

\subsubsection{Hjemmesidens opbygning} % (fold)

Siden er opbygget 5 hovedsider. 
\begin{itemize}
  \item Brugere
  \item Råvarer
  \item Råvare batch
  \item Recepter
  \item Produktions batch
\end{itemize}

Disse sider fungerer som administrations vinduer hvert emne.  Det er her at man oprette, slette eller rediger elementer inde for hvert område. 
SITEMAP HER
Hvis man tager et kig på brugeradministrationen. Så kan man se at i toppen af siden er der knapper til at Oprette, Rediger og Slette brugere. Under knapperne er listen af brugere der er oprettet i systemet. I listen står der brugerens ID, deres navn samt hvilket niveau de har. Hvis man yderligere trykker ind på en bruger, får man alle informationer præsenteret som systemet rummer.  Disse oplysninger, undtagen brugeres ID, er mulige at ændre. 

% subsubsection Hjemmesidens opbygning (end)

% subsection Design (end)

\subsection{Implementation} % (fold)

Når en brugeren trykker på en knap bliver der sendt et event via POST som WebController opfanger og behandler. Flowet for hvordan et event på hjemmesiden bevæger sig igennem WebControlleren kan illustreres på denne måde. 
 
\begin{center}
  \textbf{ Figure 1 - WebControllerens behandling af et event }
\end{center}

Hvis konverteringen af  eventet fra en String til et Enum fejler eller hvis eventet ikke er sat, vil det blive sat til at være LoginPage hvilket vil få siden til at dirigerer brugeren hen til login siden. I setup funktionen bliver alle funktion klasser oprettet hvis de endnu ikke er oprettet. Dette sker første gang at siden bliver loadet, og de vil efterfølgende bliver lagt ind applikationens scopet. Første gang brugeren oprette forbindelse til siden bliver der lagt en login bean ind i sessions scopet. Det er denne bean som tjekker, og holder styr på om brugeren er logget ind eller om der er fejl. Hvis brugeren er logget ind, går controlleren videre til at udfører den handling brugeren har ønsket. En handling kunne være at gå til brugeradministrationen, at oprette en bruger eller noget tredje. 

\textbf{Vis linje 69 til 95 fra WebController}

\subsubsection{Data fra databasen ud til brugeren} % (fold)

Måden data bliver sendt fra databasen og ud til brugeren er vedhjælp af session og request scopet. Hvis brugeren ønsker at lave en ændring, vil dataen blive sendt via et sessions objekt ellers bliver den sendt som et request.  Alt data bliver indhentet og håndteret af servlet, dettes gøres således at der ikke er nogen direkte forbindelse mellem jsp siderne og databasen, men kun til DTO objekterne.   

% subsubsection Data fra databasen ud til brugeren (end)

\subsubsection{Sikring mod ændring af ID numre} % (fold)

Når brugeren ønsker at lave en ændring på et af dataobjekterne, f.eks. en operator, bliver den valgtes operators informationer sendt ud til brugeren vedhjælp af session scopet. For at sikre at brugeren ikke ændrer på ID nummeret direkte i html koden, hentes alle tidligere informationer ud af session scopet igen.  Dernæst opdateres alle andre felter end ID feltet med det brugeren har indtastet.

% subsubsection Sikring mod ændring af ID numre (end)

\subsubsection{Beskeder til brugeren} % (fold)

Til at kunne kommunikerer med brugeren, er der blevet implementeret til et besked system. Besked systemet er lavet sådan at det er muligt at give 3 forskellige niveauer info, fejl og succes. Alt efter hvilket niveau beskeden er, ændre farven sig på beskeden. 

Beskeder bliver videregivet via et Arraylists af Messenges i request scopet. På hver side på hjemmesiden bliver Messenges.jsp inkluderet. Det er på Messenges.jsp at beskederne bliver håndteret og vist for brugeren. Ved at sende det via request scopet er vi sikre på at levetiden på dem, kun er for den enkelte side. Det gør at vi altid at sikre på at beskeder bliver givet på de korrekt tidspunkt, og forsvinder igen når der ikke er brug for dem.

\textbf{BIILED af Beskeder / Ligger i Grafik jpg - png}

% subsubsection Beskeder til brugeren (end)

\subsubsection{Web.XML} % (fold)

Alle jsp siderne er blevet beskyttet mod at man direkte kan tilgå dem. Dette er gjort for at sikre at alle brugere bliver styret at WebControlleren. Metoden vi har brugt til at gøre dette er ved at alle jsp siderne ligger i kataloget WEB-INF. Dette katalog kan ikke direkte tilgås, men kun ved at blive redirectet fra WebControlleren. 

Når folk går ind på siden vil de vedhjælp af web.xml filen blive dirigeret til WebControlleren. Dette gøres ved at tilføje WebControlleren som en servlet, samt at tilføje servlet navnet til welcome listen. Yderligere har vi tilføjet /m,/M,/mobile og /mobile til XML filen, det gør at man vedhjælp af disse henvisninger kan få fat i den mobile udgave af hjemmesiden.

\textbf{Vis et aktuelt billede af Web.XML}

% subsubsection Web.XML (end)

\subsubsection{Error handling} % (fold)

På hjemmesiden kan der opstår mange former for fejl. De mest kritiske fejl der kan ske, er hvis der opstår SQL fejl. Sådanne fej vil, hvis der ikke tages hånd om dem, resultere i at hjemmesiden stopper med at virke. Der kan opstå 2 kritiske SQL fejl, den ene er at der ikke kan oprettes forbindelse til databasen, i sådanne tilfælde vil brugerne blive sendt til en fejlside hvor på der står at de skal forsøge igen senere, da hjemmesiden ikke vil virke. Den anden SQL fejl der kan komme er hvis der sker en fejl med en query eller update, disse fejl er ikke så kritiske at siden skal lukke ned, men brugeren skal stadig gøres opmærksom på at der er opstået en fejl. Hvis der sker sådanne en fejl, vil brugeren blive sendt tilbage til oversigts siden for det respektive område og der vil være en rød informations boks som orientere brugeren om fejlen.

% subsubsection Error handling (end)

\subsubsection{Mobil side} % (fold)

Vi har lavet en side til brug på mobiltelefoner og tablets. Fra denne side er det muligt at få et overblik over hvilke råvare der mangler at blive afvejet for alle de produktionsbatche der endnu ikke er afsluttet. Ideen er at i stedet for at skulle printe en liste af produktionskomponenterne ud, kan operatørerne vedhjælp af deres telefon altid få et hurtigt og altid opdateret overblik. 

\begin{center}
  Billeder af: Login, Produktionsbatch, Overview (i den rækkefølge, ligger i mobil hjemmeside, må gerne stå på række)
\end{center}

Siden er opbygget på samme måde som den normale udgave. Forskellen er at den er grafiskoptimeret til at fungerer på meget små skærme. Derfor tjekkes det om brugeren bruger en mobil webbrowser, hvis det ikke er tilfældet, sendes brugeren hen til den normale version af hjemmesiden. Metoden vi benytter til at tjekke browser versionen er ved at sammenligne brugerens user-agent, som man får ved at kalde request.getHeader("user-agent"), med en liste af forskellige kendte mobilbrowsere. Det er derfor muligt, hvis brugeren manuelt ændrer deres user-agent, at komme ind på mobilsiden, men det har vi dog valgt at se bort fra, da det ikke er kritisk at afskærme brugeren.  Mobil siden er designet med et responsive style sheet, det gør at alt efter hvor stor opløsning browseren har, ændre designet sig så det passer.

Dette gøres ved at lave nogle regler for hvornår hvilke sektioner af css filen skal benyttes, måden man gør dette på er ved at skrive f.eks. @media (max-width: 767px) \{. Det betyder, at alt der kommer inden i \{ \} kun skal bruges så længe browseren har en opløsning på mindre end 767px.

% subsubsection Mobil side (end)

\subsubsection{Diagrammer} % (fold)

Sekvensdiagrammer
Recept tilføjelse
Når man ønsker at tilføje en ny recept skal man først oprette navnet på recepten. Derefter tilføjer man de komponenter man ønsker at recepten skal indeholde. Dette gøres ved at men en efter en vælger hvilken råvare man vil benytte, mængden samt hvilken en tolerance man ønsker. 
BILLED: Flowdiagram - Opret Recept.png


% subsubsection Diagrammer (end)

% subsection Implementation (end)

\subsection{Test} % (fold)

For at få testet hjemmesiden funktionalitet har vi opdelt testen i flere små dele.

\begin{itemize}
  \item Validering
    \begin{itemize}
      \item Klient side
      \item Server side
    \end{itemize}
\item Funktionalitets test
\end{itemize}

Ved funktionalitetstesten har vi forsøgt at kører alle senarier igennem. Vi har taget alle use-cases og afprøvet, og sikret os at alle sider funger efter hensigten. Da udviklingen af hjemmesiden har været præget af en iterativ udviklings proces, hvor vi har udviklet en funktion af gangen. Er der også undervejs blevet test og afprøvet at hver enkel funktion har gjort hvad den var tiltænkt. Under test processen opdagede vi flere steder ting som ikke opførte sig som de skulle, der var flere steder hvor knapper ikke førte de til de korrekte sider andre små ting som efterfølgende er blevet rettet. 

Testen af serverside valideringen er blevet lavet i 2 omgange, først har vi vedhjælp af siden http://gskinner.com/RegExr/, testet vores regular expression for at sikre at de virker. Dernæst har vi testet vores validator for også at sikre den fungerede med udtrykkene. Grunden måden jQuery validator er bygget op, har vi testet denne vedhjælp af en grænseværdi test. Vi har i alle inputfelter indtastet kritiske værdier for at teste om det virker, dvs. at hvis et input felt skal have mellem 2 og 20 karakterer har vi forsøgt at indtaste 1,2,20 og 21 karaktere.  

% subsection Test (end)

% section Hjemmeside (end)

\section{Simulator} % (fold)

\subsection{Analyse} % (fold)

% subsection Analyse (end)

\subsection{Design} % (fold)

% subsection Design (end)

\subsection{Implementation} % (fold)

I implementeringen af vægt simulatoren, har vi benyttede os af nogle af de forskellige emner vi har været i gennem i løbet af semestret. Vi har blandt andet benyttede os af Threads for at få serveren og, protokollen til at køre samme tid. Der er også blevet benyttet socket programmering, til at konstruere vores server, så den er i stand til at kommunikere med vores ASE. Til sidst for at gøre det mere brugervenligt har vi også implementeret en GUI, for at gøre simulatoren mere overskuelig at benytte. Vi har dog valgt kun at implementere de kommandoer vi benytter os (se krav for kommandoer).

\subsubsection{Threads} % (fold)

Tråde, har vi også valgt at benytte, i vores vægt simulator, da det gjorde det nemmere, at få forespørgsler ind, og samme tid få simulatoren til at behandle dem. Måden vi har sat det op på, er ved at få 2 tråde til at køre, en der kørte protokollen, og en der kørte serveren. For at sørger for at vi altid behandler den nyeste forespørgsel, benytter vi os af java’s egen buffer ”ArrayBlockingQueue”. I denne benytter vi os af put, til at tilføje forespørgsler, og take til at hive forespørgslerne ud. Take sørger samme tid for at vente på en forespørgsel, hvis der ikke er en i bufferen. I koden neden under ses hvordan vores protokol tråden køre, hvor man kan se, at vi benytter os af queue.take(), til at hente og fjerne det første request, der er i bufferen queue.

\begin{center}
ScaleProtocol.java linje 30-42

Tilhørende tekst: Denne metode, er tråden der tilhører vores ScaleProtocol.
\end{center}

% subsubsection Threads (end)

\subsubsection{Server} % (fold)

For at få sat vores server op, benyttede vi os af sockets, for at kunne åbne en forbindelse, der benyttes af vores vægt simulator, som lytter på en selv valgt port som ikke bliver benyttet, i vores tilfælde er det port 8000.

For at kunne få vægt simulatoren til at acceptere klienter, stater vi med at oprette en ServerSocket på port 8000. Efterfulgt af dette, skal vi gøre det muligt for en klient at skabe en forbindelse til vores server, dette gør vi ved brug af serverSocket.accept() (se kode neden under). Denne metode lytter efter en forbindelse, og venter på at en forbindelse er skabt, denne forbindelse bliver så lig en ny Socket, som så er vores klient. 

\begin{center}
ScaleServer.java linje 57-68
Tilhørende tekst: Denne metode, sørger for at simulatoren kan acceptere en klient.
\end{center}

Efter dette åbner vi så op for strømmene så vi kan få forespørgsler ind og sender svar til klienten. Klienten kan blandt andet være vores ASE, men vi kan dog også forbinde til vægt simulatoren via en Telnet klient, dette vil vi dog kommer mere ind på i test.

% subsubsection Server (end)

\subsubsection{Graphical User Interface} % (fold)

I vores implementering af GUI, har vi både benyttede os af swing og awt, da swing bliver benyttede til at sætte alle elementer op vi skal bruge som knapper, tekst felter. Awt bliver brugt til fx at lave forskellige kommandoer når man trykker på en knap, det benyttes dog også, til at definere forskellige indstillinger i swing elementerne, som fx layout. På billedet neden under ses hvordan vi har designet vores gui, der skal dog siges at den er lavet uden brug af en gui builder.

\begin{center}
screenDumb1.png

Tilhørende tekst: Når programmet starter, ser gui’en således ud, hvor man kan se, at den venter på at en klient, forbinder til den.
\end{center}

Det layout vi har valgt at benytte os af er ”GridBagLayout”, da det giver større frihed med designet. Måden det fungere på, er at det er sat op som et gitter, hvor man så kan bestemme hvor i gitteret det skal placeres, og hvor mange felter det skal fylde. Det vi benytter os til at definere positionen i vores panel er GridBagConstraints, hvor man så kan vælge positionen, bredden, højden og meget mere.

\begin{center}
GUIDisplay.java linje 87-99

Tilhørende tekst: Metoden vi benytter til at bestemme, komponenternes position, og hvordan det skal sættes op i vores panel.
\end{center}

Måden vi har valgt at implementere vores knapper, er lidt mere anderledes, inde de andre komponenter vi benytter os. Det vi har gjort, er at kreere 5 JButton’s arrays som alle består af 6 Jbutten’s, hvor 4 er dem er forskellige. Grunden til vi benytter os af så mange, er at det er forskelligt hvad knapperne skal gøre, for hver kommando der skal benytte sig af knapperne. Hver gang der kommer en ny kommando ind, som skal bruge et andet sæt knapper, sørger vi så for at skifte det nuværende panel ud, med det panel der høre til den kommando. For altid at kunne referere til det rigtige sæt af knapper, har vi et ekstra array, som så hele tiden bliver sat lig det nuværende sæt, så det altid er de rigtige knapper vi refererer til.

\begin{center}
GUI.java linje 67-77

Tilhørende tekst: Metoden vi benytter når vi går hen til en ny kommando.
\end{center}

For at forbedre brugervenligheden i GUI, fik vi også implementeret en KeyListener. Her valgte vi at få den til trykke den femte knap ned, når man har fokus, i det tekst felt der kan skrives i, og man trykker på enter.

% subsubsection Graphical User Interface (end)

% subsection Implementation (end)

\subsection{Test} % (fold)

For at kunne teste simulatoren, har vi skulle bruge en klient, der kunne oprette forbindelse simulatorens server. Her brugte vi blandt andet en telnet klient, for at teste hver enkelt kommando, for at se om alle de svar den kunne komme med, virkede. Vi har dog også fået testet det via vores ASE, for at sikre overgange fra kommando til kommando.

\subsubsection{Telnet} % (fold)

I billedet der ses nedenunder, benytter vi os af putty’s telnet klient, til at oprette forbindelse til vores simulator. Det man kan se vi tester, er de mere simple kommandoer S, T og Z, som står for at hente, tara’ere og nulstille vægten. Som der ses på billedet, starter vi med at tjekke hvad vi egentlig har på vægten ved brug af S, her efter tara’ere vi vægten med T, og tjekker hvor meget der så er på vægten bagefter. Herefter lægger vi mere på vægten, hvorefter vi ser hvor meget vægt der ligger på vægten. Til sidst nulstiller vi så vægten med Z, og undersøger om den er blevet nulstillet med S.

\begin{center}
screenDumb2.png

Tilhørende tekst: Test af S, T og Z kommandoerne, se bilag screenDumb3.png for billede af simulator efter der er tilføjet 0,87 kg.
\end{center}

Nogle af de fejl vi stødte på ved brug disse kommandoer, var måden vi tara’ere i simulatoren var forkert. Det der var meningen simulatoren skulle gøre, var at sætte tara lig den nuværende netto, det den dog gjorde, var at ligge netto til tara. Så hvis tara er lig 0.5 kg og netto er lig 1.3 kg, og man tara’ere så vil tara blive lig 1.8 kg og netto lig 0.0 kg, det den dog skulle gøre var at sætte tara lig 1.3 kg og netto lig 0.0 kg.

Med de mere komplicerede kommandoer, kan der komme flere svar tilbage til klienten, som alle skal testes. Vi starter med RM20 kommandoen, og når kommandoen er sat i gang, kan man kun kontakte simulatoren med S, T og Z, ind til kommandoen er overstået, hvis man prøver andre kommandoer, kommer svaret ”RM20 I” tilbage. Derfor valgte vi med at teste taste fejl til at starte med, og så længe kommandoen starter med RM20, kan simulatoren ligesom vægten forstå kommandoen, men ikke udeføre den da en parameter er forkert. Hvis kommandoen er skrevet korrekt (RM20 8 ”Tekst” ”” ””), vil simulatoren sende ”RM20 B”, hvilket betyder kommandoen er udført, og venter på bruger input. Dette vil få vores simulator til at vise teksten, og skifte til knapperne for RM20, samt vente på bruger input, som kan ses på billedet neden under.

\begin{center}
screenDumb6.png

Tilhørende tekst: Efter RM20 8 Kommandoen er sendt til simulatoren.
\end{center}

Som der ses på screenDumb6.png, er der 2 knapper ok og cancel, hvis ok knappen bliver tastet bliver der sendt RM20 A ”Tekst” tilbage, hvor ”Tekst” er det brugeren har skrevet. Hvorimod hvis der bliver trykket cancel ville klienten få RM20 C svaret.

\begin{center}
screenDumb5.png

Tilhørende tekst: Telnet konsollen for vores test af RM20 8 kommandoen.
\end{center}

Ved denne test, stødte vi dog ikke på nogen større fejl programmet, en af fejlene vi stødte på var at vi havde glemt at tilføje svaret hvis en kommando havde fået en forkert parameter ind.

Billedere af de andre test der lavet i telnet kan findes i bilag.

% subsubsection Telnet (end)

\subsubsection{ASE} % (fold)

Ved test op af ASE’en, gav det os en bedre mulighed, for at teste kommandoerne oppe af hinanden, for at se om overgangen mellem dem, kørte som den skulle, og at der ikke poppede nogen fejl op. Efter første udlæg af gui’en, da vi testede det op af ASE’en, fandt vi ud af at måden vi havde lavet knapperne på, ikke fungerede ordenligt, da det endte med at der blev udført flere kommandoer når der blev trukket på en knap. Dette gjorde at vi måtte lave dette design om, hvilket betød at vi endte med at benyttede flere arrays af knapper (Se Implementering GUI).

Ved næste test op af ASE’en endte vi med en fejl, vi ikke kunne forstå kom, da det ikke gav mening, at fejlen dukkede op på det tidspunkt, og ikke noget andet tidspunkt. Der fejlen opstod, var, når vi prøvet at sætte teksten i et JTextField, men ikke hver gang, og ikke på alle computere. Det fejlen gjorde, var at fryse vores program, så vi ikke kunne gøre noget, og der poppede ikke nogle exception op. Denne fejl fiksede vi ved ændre det JTextField der skabte problemet til JTextArea, dette gjorde at problemet ikke længere opstod. Vi fandt dog aldrig ud af hvorfor denne fejl opstod. Men da den kun kom frem på nogle computere, tænkte vi at det nok have noget at gøre, med hvilken version af java, der blev benyttede på de forskellige computere.

Da dette blev rettet, begyndte en NullPointerException i ”AWT-EventQueue-0” tråden, at poppe op nogle gange. Denne exception skaber dog ikke problemer, i vores program, den popper bare nogle gange op, når der bliver tastet på knapperne, det er dog sjældent, og som den forrige fejl poppede den kun op på nogle computere.

\begin{center}
  Fejl fra skolens computere 
\end{center}

% subsubsection ASE (end)

% subsection Test (end)

% section Simulator (end)

\section{Afvejnings Styrings Enhed} % (fold)

\subsection{Analyse} % (fold)

Afvejnings Styrings Enhed (herfra omtalt ASE) har ansvaret for at håndtere afvejnings proceduren som operatøren foretager ved vægten. Vægten er som sådan et "dumt" apperat og kan på egen hånd ikke foretage andet end at give operatøren umiddelbare resultater af afvejningen i dens display. Det er derfor nødvendigt med et komponent som gør at operatøren kan handle op imod informationer der er lagret i databasen.

For at kunne konkretisere dette, er det nødvendigt at se på hvordan en afvejningsprocedure (kan) forløbe. Ud fra kundens oplæg til afvejningsproceduren er følgende antagelser gjort.

\paragraph{Operatøren skal kunne identificere sig overfor vægten} % (fold)

I databasen er operatører repræsenteret ved deres unikke operatør ID. Grundet dette, og det faktum at vægten har begrænsede muligheder for bruger input, er det oplagt at operatøren identificerer sig ved sit ID. Det er kort og koncist.

Operatører, ligesom alle andre brugere, har også et password tilknyttet. Det vil være oplagt at operatøren også skulle angive dette når denne identificerer sig ved vægten, sådan at det rent faktisk kan bekræftes at det er denne operatør. Den eneste måde vægten kan tage imod input er via dens "tastatur", som på et givent tidspunkt kun tage imod input på én af følgende tre måder:
\begin{itemize}
  \item Heltal
  \item Små bogstaver
  \item Store bogstaver
\end{itemize}
Vægten kan i princippet tage imod flere typer af input, men essensen er at der kun er én af disse typer der kan være aktiv på samme tidspunkt. Passwords er ofte angivet som en kombination af alle disse tre typer, hvorfor det ikke som udgangspunkt er muligt at kræve at operatøren indtaster dette.

Når en operatør har indtastet sit ID, skal ASE'en tjekke at det indtastede ID rent faktisk tilhører en operatør (og ikke en værkfører, adminstrator eller lignende), og efterfølgende præsentere operatørens navn i vægtens display, sådan at denne kan be- eller afkræfte at den korrekte operatør er fundet.

% paragraph Operatøren skal kunne identificere sig overfor vægten (end)

\paragraph{Operatøren skal vælge et produktbatch} % (fold)

Værkføreren opretter ud fra systemets recepter, produktbatches som ønskes produceret, hvilket er operatørens opgave.

Produktbatches er repræsenteret ved et entydigt produktbatch-id. Når en operatør indtaster dette skal denne præsenteres for navnet på recepten som produktbatchet skal produceres ud fra, og herefter bekræfte om dette er korrekt.

ASE'en skal tillige tjekke om et valgt produktbatch allerede er afsluttet. Er dette tilfældet bedes operatøren vælge et andet batch.

% paragraph Operatøren skal vælge et produktbatch (end)

\paragraph{Operatøren skal vælge et råvarebatch} % (fold)

Et produktbatch er baseret på en recept. En recept består af forskellige råvarer i variende mængde. Når operatøren har valgt et produktbatch som skal produceres, skal denne altså afveje én eller flere råvarer der indgår i recepten som produktbatchet er baseret på. Råvarer opgivet i recepten er dog ikke konkrete råvarer der er på lager, men findes istedet som råvarebatches. For hver råvare der skal afvejes skal operatøren således angive et råvarebatch som der afmåles fra.

ASE'ens opgave er her at præsentere operatøren for den råvare der nu skal afvejes, således at operatøren kan gå ud på lageret og finde et råvarebatch af den specifikke råvare. Her er det oplagt at ASE'en præsenterer operatøren for de råvarebatches (angivet ved deres unikke id) som er af den rette type. Desuden er det oplagt at ASE'en også tager højde for om råvarebatchet indeholder tilstrækkelig mængde af råvaren (i forhold til den netto værdi der er angivet i recepten).

Når operatøren har fundet et råvarebatch indtaster han dets unikke ID, og ASE'en tjekker om
\begin{enumerate}
  \item Råvarebatchet er af den korrekte råvare
  \item Råvare batchet indeholder tilstrækkelig mængde
\end{enumerate}

Er der tale om et korrekt råvarebatch kan ASE'en fortsætte til selve afvejningsproceduren

% paragraph Operatøren skal vælge et raavarebatch (end)

\paragraph{Vægten skal være tom inden tarering og afvejning} % (fold)

Inden at vægten kan tareres, er det vægten at kontrollere at vægten er tom, således at det sikres at der ikke er materiale på vægten der kan give en forkert afmåling. ASE'en skal derfor bede operatøren om at kontrollere dette og bekræfte. ASE'en tarerer herefter vægten, og tjekker om tarerings værdien er lige nul. Er dette ikke tilfældet bedes operatøren tjekke igen. Dette fortsætter indtil ASE'en bekræfter at vægten er tareret med tareringsværdi på nul.

% paragraph Vægten skal være tom inden tarering og afvejning (end)

\paragraph{Tara beholderens vægt skal registreres og vægten tareres} % (fold)

For at kunne registrere en afvejnings netto værdi, er det vigtigt at vægten af beholderen som råvaren afmåles i er registreret. ASE'en skal derfor bede operatøren om at placere beholderen på vægten og trykke OK når denne er klar til at tarere.

Ved tryk på OK sender ASE'en signal til vægten om at tarere, og ASE'en registrerer den svarede tarerings værdi for dette produktbatchkomponent.

% paragraph Tara beholderens vægt skal registreres og vægten tareres (end)

\paragraph{Råvare skal afvejes i korrekt mængde} % (fold)

Et recept komponent er angivet ved en nominel netto værdi af en råvare, plus en tolerance for denne værdi. Tolerancen kan være mellem 0.1\% og 10\% af den nominelle netto værdi. Dette betyder altså at er den nominielle netto værdi for et recept komponent \textbf{1 kg} og tolerancen er \textbf{10\%} er en korrekt afmåling mellem \textbf{0.900 kg} og \textbf{1.100 kg}.

ASE'en skal derfor bede operatøren afmåle en mængde af råvaren der ligger i dette interval. Når operatøren har gjort dette, trykker denne ok og ASE'en tjekker om afmålingen rent faktisk ligger i intervallet. Er dette ikke tilfældet bedes operatøren om at justere afvejningen indtil denne er korrekt.

Er afvejningen korrekt gemmes denne og proceduren starter "forfra", hvor operatøren skal afveje en ny råvare og dermed vælge et nyt råvarebatch.

% paragraph Råvare skal afvejes i korrekt mængde (end)

\paragraph{ASE'en skal registrere start- og slutdato for produktionen} % (fold)

Et produktbatch kan have én af følgende tre tilstande:
\begin{itemize}
  \item Ikke påbegyndt
  \item Under produktion
  \item Afsluttet
\end{itemize}

Når et produktbatch oprettes, er dette som standard i en endnu ikke påbegyndt tilstand. Når en operatør har afvejet det første komponent er produktbatchet under produktion. Når alle komponenter er afvejet er produktionen afsluttet.

ASE'en skal derfor ved første afvejning sætte tilstanden til 'under produktion' og registrere starttidspunktet for produktionen. Når ASE'en registrerer at alle komponenter er afvejet sættes tilstanden til 'afsluttet' og sluttidspunktet for produktionen registreres.

% paragraph ASE'en skal registrere start- og slutdato for produktionen (end)

\paragraph{En produktion kan afbrydes undervejs og genoptages senere} % (fold)

Det er ikke nødvendigt for en operatør at afveje alle komponenter for et produktbatch, men kan afveje ét eller flere i en session. Afbrydes der undervejs skal ASE'en således kun gemme \emph{korrekte, afsluttede} afvejninger.

Genoptages produktionen på et senere tidspunkt, skal ASE'en således holde styr på hvilke komponenter der allerede ér afvejet, og således kun lede operatøren igennem afvejningen af de resterende komponenter.

% paragraph En produktion kan afbrydes undervejs (end)

% subsection Analyse (end)

\subsection{Design} % (fold)

Efter at have specificeret hvad ASE'en skal kunne, og forretningsreglerne for proceduren er præciseret, kan vi designe den generelle tilstandsmaskine der skal styre ASE'en.

Proceduren for afvejning er inkrementerende, forstået på den måde at for at nå til et senere punkt i proceduren, må operatøren nødvendigvis have gennemgået de punkter der leder op til. På sin vis kan ASE'en derfor designes som en lang procedure der kører fra start til slut. Med fordel kan der dog indføres tilstande i proceduren som er en form for gruppering af række under-procedurer. På den måde kan maskinen gå fra én tilstand til en anden, på baggrund af specifikke begivenheder.

\subsubsection{Tilstande} % (fold)

Vores ASE er inddelt i 4 tilstande, der er som følger:
\begin{itemize}
  \item \textbf{LOGIN} Tilstanden hvor operatøren skal identificere sig. Overgang til næste tilstand kan kun ske når operatøren har identificeret sig ved et gyldigt ID og bekræftet at der er tale om den rette bruger.
  \item \textbf{SELECT\_BATCH} Tilstanden hvor operatøren skal vælge et produktbatch. Overgang kan kun ske når operatøren har valgt et gyldigt produkt batch ID, for et batch der endnu ikke er afsluttet, og bekræftet at der er tale om det rette batch (ud fra den rette recept).
  \item \textbf{MEASURING} Tilstanden hvor selve afvejningen af komponenter foregår. Her indgår flere af de underprocedurer der er påkrævet for korrekt at afveje råvare til et produktions batch komponent. Denne tilstand "gentages" for hvert påkrævet komponent i recepten, indtil alle komponenter er afvejet, hvorefter ASE'en overgår til næste tilstand. Undervejs i afvejningen kan operatøren vælge at afbryde produktionen, hvorefter maskinen også vil overgå til næste tilstand.
  \item \textbf{FINISHED} Tilstanden hvor operatøren enten helt, eller delvist, har afsluttet produktionen af et produktbatch. Denne tilstand sikrer at alle afvejede komponenter er korrekt gemt (disse bliver løbende gemt som de bliver afvejet) og sikrer at produktiones batchet har den rette status (ikke påbegyndt, under produktion eller afsluttet). Herefter nulstiller ASE'en sig og tilstanden overgår til \texttt{LOGIN}.
\end{itemize}

ASE'en er som sådan ikke en komplet tilstandmaskine, idet de forskellige tilstande ikke entydigt repræsenterer et bestemt output. Ligeledes er systemets begivenheder (beskrevet senere) ikke direkte årsag til skift mellem tilstande, men medførende til at opfylde den række af kriterier der skal være opfyldt før maskinen kan skifte til en ny tilstand.

% subsubsection Tilstande (end)

\subsubsection{Begivenheder} % (fold)

Kommunikationen med vægten (eller simulatoren) foregår via TCP/IP protokollen, via hvilken der sendes forespørgsler og svar. En forespørgsel fra ASE til vægt giver altid et eller flere svar. Når der sendes en bestemt forespørgsel forventes altså altid et eller flere bestemte svar der svarer specifikt til forespørgslen. På baggrund af dette, er der i ASE'en oprettet en række begivenheder (Events) der, som tidligere nævnt, ikke altid direkte ændrer tilstanden i ASE'en, men medivrker til at opfylde en række kriterier der gør at der kan skiftes tilstand.

Begivenhederne er som følger:

\begin{itemize}
  \item \textbf{COMMAND\_UNDERSTOOD} Antyder at en forespørgsel er forstået, og at der \emph{kan} forventes opfølgende svar. Dette sker eksempelvis ved en \texttt{RM20} kommando, hvor vægten først svarer om kommandoen er forstået (og klar til at blive udført - altså der ikke er andre aktive forespørgsler der har precedens over den aktuelle forespørgsel), og efterfølgende svarer med resultatet af forespørgslen på baggrund af operatørens input
  \item \textbf{OK\_PRESSED} Antyder at brugeren har bekræftet en dialogboks fra en \texttt{RM49} kommando, eller at der er trykker OK i forbindelse med tarering/afvejning. I den sammenhæng antyder et ok, at ASE'en kan sende en forespørgsel om vægtens belastning (eller tareringsværdi) og at et korrekt resultat forventes.
  \item \textbf{CANCEL\_PRESSED} Antyder at brugeren har "annuleret" en dialog, eller trykket Cancel/annuler under en afvejning
  \item \textbf{EXIT\_PRESSED} Antyder at brugeren har trykket 'Afslut' og ønsker at afbryde afvejningen
  \item \textbf{SCALE\_READ} Antyder at vægten har svaret på en \texttt{S}-kommando med vægtens belastning
  \item \textbf{SCALE\_TARED} Antyder at vægten har svaret på en \texttt{T}-kommando (tarering), hvor vægten er blevet tareret og tarerings værdien fremgår af svaret.
  \item \textbf{SCALE\_ZEROED} Antyder at vægten er blevet nulstillet, altså primært at tarerings værdien er blevet nulstillet.
  \item \textbf{INTEGER\_RECEIVED} Antyder at operatøren har svaret på en \texttt{RM20}-dialog med et heltal. Eksempelvis når operatøren skal indtaste sit ID.
  \item \textbf{EMPTY} \textbf{!!! Fjern evt denne !!!}
  \item \textbf{NOTHING} \textbf{!!! Fjern evt denne !!!}
\end{itemize}

Ved begivenheder hvor der er tilknyttet et resultat (\texttt{SCALE\_READ}, \texttt{SCALE\_TARED} og \texttt{INTEGER\_RECEIVED}) bliver dette lagret i passende attributter som ASE'en kan tilgå.

% subsubsection Begivenheder (end)

\subsubsection{Kommunikation med vægt} % (fold)

Hvordan den asynkront kan sende og modtage data fra vægten.

Skriv om klassen til at håndtere kommunikation

% subsubsection Kommunikation med vægt (end)

% subsection Design (end)

\subsection{Implementation} % (fold)

% subsection Implementation (end)

\subsection{Test} % (fold)

% subsection Test (end)

% section Afvejnings Styrings Enhed (end)

\end{document}
